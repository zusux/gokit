// protoc-gen-tag: A simple protoc plugin for adding multiple struct tags
// Usage: protoc --go_out=. --tag_out=. your.proto

package main

import (
	"fmt"
	"google.golang.org/protobuf/types/pluginpb"
	"strings"

	"github.com/zusux/gokit/gen/protoc-gen-tag/tag"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/runtime/protoimpl"
	"google.golang.org/protobuf/types/descriptorpb"
)

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range plugin.Files {
			if !f.Generate {
				continue
			}
			generateFile(plugin, f)
		}
		return nil
	})
}

func generateFile(plugin *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + ".tag.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-tag. DO NOT EDIT.")
	g.P("package ", file.GoPackageName)

	for _, message := range file.Messages {

		GenerateMessageStruct(g, message)
		GenerateToTagFunc(g, message)
		GenerateFromTagFunc(g, message)
	}
}

func buildTag(field *protogen.Field) string {
	opts := field.Desc.Options().(*descriptorpb.FieldOptions)
	var tags []string
	if val, ok := getTag(opts, tag.E_Json); ok {
		tags = append(tags, fmt.Sprintf(`json:"%s"`, val))
	} else {
		tags = append(tags, fmt.Sprintf(`json:"%s,omitempty"`, field.Desc.Name()))
	}
	if val, ok := getTag(opts, tag.E_Bson); ok {
		tags = append(tags, fmt.Sprintf(`bson:"%s"`, val))
	}
	if val, ok := getTag(opts, tag.E_Yaml); ok {
		tags = append(tags, fmt.Sprintf(`yaml:"%s"`, val))
	}
	if val, ok := getTag(opts, tag.E_Gorm); ok {
		tags = append(tags, fmt.Sprintf(`gorm:"%s"`, val))
	}
	return strings.Join(tags, " ")
}

func getTag(opts *descriptorpb.FieldOptions, ext *protoimpl.ExtensionInfo) (string, bool) {
	if proto.HasExtension(opts, ext) {
		val := proto.GetExtension(opts, ext)
		if s, ok := val.(string); ok {
			return s, true
		}
	}
	return "", false
}

func goFieldType(field *protogen.Field) string {
	if field.Enum != nil || field.Message != nil {
		return field.GoIdent.GoName + "Tag"
	}

	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		return "bool"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.FloatKind:
		return "float32"
	case protoreflect.DoubleKind:
		return "float64"
	case protoreflect.StringKind:
		return "string"
	case protoreflect.BytesKind:
		return "[]byte"
	default:
		return "interface{}"
	}
}

//------------

func GenerateMessageStruct(g *protogen.GeneratedFile, message *protogen.Message) {
	g.P("type ", message.GoIdent.GoName, "Tag struct {")
	for _, field := range message.Fields {
		fieldName := field.GoName
		fieldType := fieldTypeWithTagSuffix(field)
		structTag := buildTag(field)
		g.P(fieldName, " ", fieldType, " `", structTag, "`")
	}
	g.P("}")
	g.P()
}

func fieldTypeWithTagSuffix(field *protogen.Field) string {
	if field.Desc.IsMap() {
		keyKind := field.Desc.MapKey().Kind()
		valKind := field.Desc.MapValue().Kind()
		if field.Message != nil && field.Message.Fields[1].Message != nil {
			return fmt.Sprintf("map[%s]*%sTag", keyKind.String(), field.Message.Fields[1].Message.GoIdent.GoName)
		} else if valKind == protoreflect.MessageKind {
			return fmt.Sprintf("map[%s]*%sTag", keyKind.String(), field.Message.GoIdent.GoName)
		}
		// 对于 map<string, string> 等基本类型，直接生成 map[keyType]valueType
		return fmt.Sprintf("map[%s]%s", keyKind.String(), valKind.String())
	}

	if field.Desc.IsList() {
		if field.Message != nil {
			return "[]*" + field.Message.GoIdent.GoName + "Tag"
		}
		return "[]" + goFieldType(field)
	}
	if field.Message != nil {
		return "*" + field.Message.GoIdent.GoName + "Tag"
	}

	// Handle proto3 optional fields (which use synthetic oneof)
	if field.Desc.HasPresence() && !(field.Oneof != nil && isSyntheticOneof(field)) {
		return "*" + goFieldType(field)
	}
	return goFieldType(field)
}

func GenerateToTagFunc(g *protogen.GeneratedFile, message *protogen.Message) {
	g.P("func (x *", message.GoIdent.GoName, ") To", message.GoIdent.GoName, "Tag() *", message.GoIdent.GoName, "Tag {")
	g.P("if x == nil { return nil }")
	g.P("return &", message.GoIdent.GoName, "Tag{")
	for _, field := range message.Fields {
		name := field.GoName
		if field.Desc.IsMap() {
			if field.Desc.MapValue().Kind() == protoreflect.MessageKind {
				// map 值类型是消息类型
				g.P(name, ": func() map[string]*", field.Desc.MapValue().Message().Name(), "Tag {")
				g.P("out := make(map[string]*", field.Desc.MapValue().Message().Name(), "Tag)")
				g.P("for k, v := range x.", name, " {")
				g.P("out[k] = v.To", field.Desc.MapValue().Message().Name(), "Tag()")
				g.P("}")
				g.P("return out")
				g.P("}(),")
			} else {
				// map 值类型是基本类型（如 string）
				g.P(name, ": x.", name, ",")
			}
		} else if field.Desc.IsList() && field.Message != nil {
			g.P(name, ": func() []*", field.Message.GoIdent.GoName, "Tag {")
			g.P("out := make([]*", field.Message.GoIdent.GoName, "Tag, len(x.", name, "))")
			g.P("for i, v := range x.", name, " { out[i] = v.To", field.Message.GoIdent.GoName, "Tag() }")
			g.P("return out }(),")
		} else if field.Message != nil {
			g.P(name, ": x.", name, ".To", field.Message.GoIdent.GoName, "Tag(),")
		} else {
			g.P(name, ": x.", name, ",")
		}
	}
	g.P("} }")
}

func GenerateFromTagFunc(g *protogen.GeneratedFile, message *protogen.Message) {
	g.P("func (x *", message.GoIdent.GoName, "Tag) To", message.GoIdent.GoName, "() *", message.GoIdent.GoName, " {")
	g.P("if x == nil { return nil }")
	g.P("return &", message.GoIdent.GoName, "{")
	for _, field := range message.Fields {
		name := field.GoName
		if field.Desc.IsMap() {
			if field.Desc.MapValue().Kind() == protoreflect.MessageKind {
				// map 值类型是消息类型
				g.P(name, ": func() map[string]*", field.Desc.MapValue().Message().Name(), " {")
				g.P("out := make(map[string]*", field.Desc.MapValue().Message().Name(), ")")
				g.P("for k, v := range x.", name, " {")
				g.P("out[k] = v.To", field.Desc.MapValue().Message().Name(), "()")
				g.P("}")
				g.P("return out")
				g.P("}(),")
			} else {
				// map 值类型是基本类型（如 string）
				g.P(name, ": x.", name, ",")
			}
		} else if field.Desc.IsList() && field.Message != nil {
			g.P(name, ": func() []*", field.Message.GoIdent.GoName, " {")
			g.P("out := make([]*", field.Message.GoIdent.GoName, ", len(x.", name, "))")
			g.P("for i, v := range x.", name, " { out[i] = v.To", field.Message.GoIdent.GoName, "() }")
			g.P("return out }(),")
		} else if field.Message != nil {
			g.P(name, ": x.", name, ".To", field.Message.GoIdent.GoName, "(),")
		} else {
			g.P(name, ": x.", name, ",")
		}
	}
	g.P("} }")
}

// isSyntheticOneof 检查 oneof 是否为合成 oneof
func isSyntheticOneof(field *protogen.Field) bool {
	if field.Oneof == nil {
		return false
	}
	// 合成 oneof 通常在 proto3 中，且只有一个字段
	if field.Parent.Desc.ParentFile().Syntax() != protoreflect.Proto3 {
		return false
	}
	// 检查 oneof 是否只包含一个字段
	oneofDesc := field.Oneof.Desc
	return oneofDesc.Fields().Len() == 1
}
